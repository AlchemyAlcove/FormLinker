{"version":3,"sources":["webpack://form-linker/webpack/bootstrap","webpack://form-linker/./src/index.js","webpack://form-linker/external \"lodash\""],"names":["options","schema","fields","calcFields","converters","formatters","masks","data","setValuesFromParsed","parsedData","originalData","Object","assign","errors","changeCallback","onChange","prefix","keys","forEach","key","push","fieldName","value","get","isNil","split","converter","triggerCallback","isEmpty","unset","nested","indexOf","currentPath","slice","lastIndexOf","set","mask","format","parsed","values","setValue","convert","response","formatted","valid","formatter","flag","i","length","getValue","setError","field","validate","original","differences","isEqual","validateAll"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","import { get, isEqual, isEmpty, isNil, set, unset } from \"lodash\";\n\nexport default class{\n  constructor(options = {}) {\n    this.schema = options.schema || {};\n    this.fields = this.calcFields();\n    this.converters = options.converters || {};\n    this.formatters = options.formatters || {};\n    this.masks = options.masks || {};\n    this.data = {};\n    this.setValuesFromParsed(options.data || {}, false);\n    this.parsedData = options.data || {};\n    this.originalData = Object.assign({}, this.parsedData);\n    this.errors = {};\n    this.changeCallback = options.onChange || function() {};\n  }\n\n  // calcFields should be used only to instantiate the fields instance variable\n  calcFields(schema = this.schema, prefix = \"\", fields = []) {\n    Object.keys(schema).forEach((key) => {\n      if(typeof schema[key] === \"object\") {\n        this.calcFields(schema[key], prefix + key + \".\", fields);\n      } else {\n        fields.push(prefix + key);\n      }\n    });\n    return(fields);\n  }\n\n  convert(fieldName, value) {\n    const key = get(this.schema, fieldName);\n\n    if(!isNil(key)) {\n      key.split(\".\").forEach((converter) => {\n        if(!isNil(this.converters[converter])) {\n          value = this.converters[converter](value);\n        }\n      });\n    }\n\n    return(value);\n  }\n\n  /*\n  // ERRORS\n  */\n\n  // getError gets the errors for a specific field\n  getError(fieldName) {\n    return(get(this.errors, fieldName) || []);\n  }\n\n  // getErrors returns the entire error object\n  getErrors() {\n    return(this.errors);\n  }\n\n  // setError removes errors data if an empty array or sets the errors. It also calls the changeCallback.\n  setError(fieldName, errors, triggerCallback = true) {\n    if(isEmpty(errors)) {\n      unset(this.errors, fieldName);\n      const nested = fieldName.indexOf(\".\") > -1;\n      if(nested) {\n        let currentPath = fieldName.slice(0, fieldName.lastIndexOf(\".\"));\n        while(currentPath) {\n          if(isEmpty(get(this.errors, currentPath))) {\n            unset(this.errors, currentPath);\n            currentPath = currentPath.slice(0, currentPath.lastIndexOf(\".\"));\n          } else {\n            break;\n          }\n        }\n      }\n    } else {\n      set(this.errors, fieldName, errors);\n    }\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  // setErrors sets the errors object. It also calls the changeCallback.\n  setErrors(errors, triggerCallback = true) {\n    this.errors = errors;\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  /*\n  // VALUES\n  */\n\n  // getValue gets the value of the field. Sets the value to an empty string if not an array, not a number, not a boolean, and empty.\n  getValue(fieldName) {\n    return(get(this.data, fieldName));\n  }\n\n  // getValues returns the data object.\n  getValues() {\n    return(this.data);\n  }\n\n  // setValue sets the field value to the masked value passed in. It also calls the changeCallback.\n  setValue(fieldName, value, triggerCallback = true) {\n    set(this.data, fieldName, this.mask(fieldName, value));\n    set(this.parsedData, fieldName, this.format(fieldName, value).parsed);\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  // setValues sets the field value to the masked value passed in. It also calls the changeCallback.\n  setValues(values, triggerCallback = true) {\n    this.fields.forEach((fieldName) => {\n      const value = get(values, fieldName);\n      if(typeof value !== \"undefined\") {\n        this.setValue(fieldName, value, false);\n      }\n    });\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  setValuesFromParsed(values) {\n    this.fields.forEach((fieldName) => {\n      const value = get(values, fieldName);\n      if(typeof value !== \"undefined\") {\n        set(this.data, fieldName, this.convert(fieldName, value));\n      }\n    });\n  }\n\n  /*\n   * FORMATTING\n  */\n\n  // format returns formatter results. If no formatter is defined for the schema key, then the formatter structure is returned assuming true.\n  format(fieldName, value) {\n    const key = get(this.schema, fieldName);\n    let response = {\n      errors: [],\n      formatted: value,\n      parsed: value,\n      valid: true\n    };\n\n    if(!isNil(key)) {\n      key.split(\".\").forEach((formatter) => {\n        if(!isNil(this.formatters[formatter])) {\n          response = this.formatters[formatter](response);\n        }\n      });\n    }\n\n    return(response);\n  }\n\n  /*\n   * MASKING\n  */\n\n  // mask masks data based on schema key. If no mask is defined for the schema key, then the original value is returned.\n  mask(fieldName, value) {\n    const key = get(this.schema, fieldName);\n    let response = value;\n\n    if(!isNil(key)) {\n      key.split(\".\").forEach((mask) => {\n        if(!isNil(this.masks[mask])) {\n          response = this.masks[mask].mask(value);\n        }\n      });\n    }\n\n    return(response);\n  }\n\n  /*\n   * VALIDATION\n  */\n\n  isValid() {\n    let flag = true;\n    for(let i = 0; i < this.fields.length; i++) {\n      const{ valid } = this.format(this.fields[i], this.getValue(this.fields[i]));\n      if(valid === false) {\n        flag = false;\n        break;\n      }\n    }\n    return(flag);\n  }\n\n  validate(fieldName, triggerCallback = true) {\n    const{ errors, formatted, parsed } = this.format(fieldName, this.getValue(fieldName));\n    this.setError(fieldName, errors, false);\n    this.setValue(fieldName, formatted, false);\n    set(this.parsedData, fieldName, parsed);\n\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  validateAll(triggerCallback = true) {\n    this.fields.forEach((field) => {\n      this.validate(field, false);\n    });\n\n    if(triggerCallback) {\n      this.changeCallback();\n    }\n  }\n\n  /*\n  // Differences\n  */\n\n  // extractDifferences returns an object of every key that has changed with the value it has changed to. This is great for sending only changes.\n  extractDifferences(original) {\n    const differences = {};\n    const data = this.parsedData;\n\n    this.fields.forEach((field) => {\n      if((isNil(get(original, field)) || get(original, field) === \"\") && (isNil(get(data, field)) || get(data, field) === \"\")) {\n        // do nothing\n      } else if(!isEqual(get(original, field), get(data, field))) {\n        set(differences, field, get(data, field));\n      }\n    });\n    return(differences);\n  }\n\n  /*\n   * SCHEMA\n  */\n\n  updateSchema(schema) {\n    this.schema = schema || {};\n    this.fields = this.calcFields();\n    this.validateAll();\n    this.errors = {};\n  }\n};\n","module.exports = require(\"lodash\");"],"sourceRoot":""}